// import React, { Fragment, useRef, useEffect, useState } from 'react';
// import { fabric } from 'fabric';
// import { initAligningGuidelines, initCenteringGuidelines } from './fabric-addon';

// const DesignCanvas = ({ width = 600, height = 400, background = '#fff', showGrid: showGridProp = false, children }) => {
//   const [canvas, setCanvas] = useState(null);
//   const gridRef = useRef(null);
//   const canvasRef = useRef(null);

//   const renderGrid = () => {
//     const gridCanvas = new fabric.Canvas(gridRef.current);
//     const options = {
//       distance: 10,
//       param: {
//         stroke: '#ebebeb',
//         strokeWidth: 1,
//         selectable: false,
//       },
//     };
//     let gridLen = width / options.distance;

//     for (let i = 0; i < gridLen; i++) {
//       let distance = i * options.distance;
//       let horizontal = new fabric.Line([distance, 0, distance, width], options.param);
//       let vertical = new fabric.Line([0, distance, width, distance], options.param);
//       gridCanvas.add(horizontal);
//       gridCanvas.add(vertical);
//       if (i % 5 === 0) {
//         horizontal.set({ stroke: '#cccccc' });
//         vertical.set({ stroke: '#cccccc' });
//       }
//     }
//   };

//   useEffect(() => {
//     const mainCanvas = new fabric.Canvas(canvasRef.current, {
//       backgroundColor: background,
//       preserveObjectStacking: true,
//     });

//     initAligningGuidelines(fabric, mainCanvas);
//     initCenteringGuidelines(fabric, mainCanvas);

//     if (showGridProp) {
//       renderGrid();
//     }
//     setCanvas(mainCanvas);

//     return () => {
//       mainCanvas.dispose();
//     };
//   }, [background, showGridProp]);

//   const renderedChildren = React.Children.map(children, child => {
//     return React.cloneElement(child, {
//       canvas: canvas,
//     });
//   });

//   return (
//     <Fragment>
//       {showGridProp && (
//         <div style={{ position: 'absolute' }}>
//           <canvas ref={gridRef} width={width} height={height} />
//         </div>
//       )}
//       <div style={{ position: 'absolute' }}>
//         <canvas ref={canvasRef} width={width} height={height} />
//       </div>
//       {canvas && renderedChildren}
//       <button
//         style={{ position: 'absolute', top: 0, right: 0 }}
//         onClick={e => {
//           e.preventDefault();
//           console.log(canvas.toJSON());
//         }}
//       >
//         Save To JSON
//       </button>
//     </Fragment>
//   );
// };

// export default DesignCanvas;
// import React, { Fragment, useRef, useEffect, useState } from 'react';
// import { fabric } from 'fabric';
// import { initAligningGuidelines, initCenteringGuidelines } from './fabric-addon';

// const DesignCanvas = ({ width = 600, height = 400, background = '#fff', showGrid: showGridProp = false, children }) => {
//   const [canvas, setCanvas] = useState(null);
//   const gridRef = useRef(null);
//   const canvasRef = useRef(null);

//   const renderGrid = () => {
//     const gridCanvas = new fabric.Canvas(gridRef.current);
//     const options = {
//       distance: 10,
//       param: {
//         stroke: '#ebebeb',
//         strokeWidth: 1,
//         selectable: false,
//       },
//     };
//     let gridLen = width / options.distance;

//     for (let i = 0; i < gridLen; i++) {
//       let distance = i * options.distance;
//       let horizontal = new fabric.Line([distance, 0, distance, width], options.param);
//       let vertical = new fabric.Line([0, distance, width, distance], options.param);
//       gridCanvas.add(horizontal);
//       gridCanvas.add(vertical);
//       if (i % 5 === 0) {
//         horizontal.set({ stroke: '#cccccc' });
//         vertical.set({ stroke: '#cccccc' });
//       }
//     }
//   };

//   useEffect(() => {
//     const mainCanvas = new fabric.Canvas(canvasRef.current, {
//       backgroundColor: background,
//       preserveObjectStacking: true,
//     });

//     initAligningGuidelines(fabric, mainCanvas);
//     initCenteringGuidelines(fabric, mainCanvas);

//     if (showGridProp) {
//       renderGrid();
//     }
//     setCanvas(mainCanvas);

//     const initialText = new fabric.Text('Your paragraph text', {
//       left: 27,
//       top: 48,
//       fontFamily: 'Arial',
//       fontSize: 26,
//     });
//     mainCanvas.add(initialText);

//     return () => {
//       mainCanvas.dispose();
//     };
//   }, [background, showGridProp]);

//   const renderedChildren = React.Children.map(children, child => {
//     return React.cloneElement(child, {
//       canvas: canvas,
//     });
//   });

//   const applyClarifyAnimation = () => {
//     const textObject = canvas.getObjects().find(obj => obj.type === 'text' && obj.text === 'Your paragraph text');
//     if (!textObject) {
//       console.error("Text object not found");
//       return;
//     }

//     const text = textObject.text;
//     const fadeRate = 0.02;
//     const maxBlur = 5;
//     const moveDistance = 20;
//     const animationTypeSpeed = 50;
//     const charPositions = [];

//     for (let i = 0; i < text.length; i++) {
//       charPositions.push({ x: textObject.left + textObject.width * (i / text.length), opacity: 0 });
//     }

//     const fadeInAni = Array.from({ length: text.length }, (_, i) => i).sort(() => Math.random() - 0.5);
//     let step = 0;

//     const animate = () => {
//       for (let i = 0; i < text.length; i++) {
//         const charIndex = fadeInAni[i];
//         const baseXPos = charPositions[charIndex].x;
//         const xPosChar = baseXPos - moveDistance + (moveDistance * Math.min(1, charPositions[charIndex].opacity));

//         if (step >= i) {
//           charPositions[charIndex].opacity = Math.min(1, charPositions[charIndex].opacity + fadeRate);
//           const blurLevel = maxBlur * (1 - charPositions[charIndex].opacity);
//           textObject.set({ left: xPosChar, opacity: charPositions[charIndex].opacity });
//           textObject.set('dirty', true);
//         }
//       }

//       canvas.renderAll();

//       if (step < text.length || charPositions.some(char => char.opacity < 1)) {
//         step++;
//         setTimeout(animate, animationTypeSpeed);
//       }
//     };

//     animate();
//   };

//   return (
//     <Fragment>
//       {showGridProp && (
//         <div style={{ position: 'absolute' }}>
//           <canvas ref={gridRef} width={width} height={height} />
//         </div>
//       )}
//       <div style={{ position: 'absolute' }}>
//         <canvas ref={canvasRef} width={width} height={height} />
//       </div>
//       {canvas && renderedChildren}
//       <button
//         style={{ position: 'absolute', top: 0, right: 0 }}
//         onClick={e => {
//           e.preventDefault();
//           applyClarifyAnimation();
//         }}
//       >
//         Apply Clarify Animation
//       </button>
//       <button
//         style={{ position: 'absolute', top: 30, right: 0 }}
//         onClick={e => {
//           e.preventDefault();
//           console.log(canvas.toJSON());
//         }}
//       >
//         Save To JSON
//       </button>
//     </Fragment>
//   );
// };

// export default DesignCanvas;
